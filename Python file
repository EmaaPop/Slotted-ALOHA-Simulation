# Slotted-Aloha Simulation

### Rules:

* Nodes transimit new packets according to a Poisson process and retransmit packets after some random time if collision is detected
* Time is slotted, and a packet can only be transmitted at the beginning of the slot
* After transmitting a packet, the node transmits a new packet after a random time offset, regardless of whether the transmission was successful or not
* The random time offset follows the uniform distribution within [0, W)

### Tasks:

* Simulates N senders for 100000 time slots
* The **slot efficiency** is defined as *# of successful slots / # of total slots*
  * Successful slot means that there is one and only one transmitted packet in the slot
  * No transmission or two or more transmission in a slot is considered not successful
* Implements the slotted ALOHA simulation
* Represents in a Pandas Dataframe our results (Number of nodes, Slot efficiency)
* Plots the slot efficiency graph while varying the number of nodes N from 1 to 64
* Each group has a different window size:
    * Group 1 --> 4
    * Group 2 --> 8
    * Group 3 --> 16
    * Group 4 --> 32
    * Group 5 --> 64
    * Group 6 --> 128

### Tips:

* Iterate through different scenarios of numbers of nodes (first only one, then two, ...)
* Each Node has a TTL (number of slots after which it will transmit, for example if a node has TTL=7, it will wait 7 slots before transmitting). TTL has to be generated randomly (between a specific range...)
* Consider each slot and the number of nodes you have for that scenario, see how many nodes are going to transmit during that particular slot. If only one transmits, that is a successful slot (remember that after the transmission, the node may want to transmit again later). If no nodes or more than one nodes transmit, that is a not successful slot (remember what happens after a collision...)
* For each slot, calculate its efficiency

### Initial code:
import random
import pandas as pd
import matplotlib.pyplot as plt

# Total number of slots
TSLOTS = 100000

# This class represents a node that wants to transmit. It will transmit after a certain number of slots (ttl)
# Each node needs to have a classNode instance with a random ttl

class classNode:
	def __init__(self, ttl):
		self.ttl = ttl # number of slots left until transmission
	def tick(self):
		self.ttl = self.ttl - 1 # Decrease number of slots

## My Code

def main():
    random.seed()

    for window_size in [8, 16, 32, 64, 128]:
        Nlist = []
        selist = []
        print("Window size: {0:2d}".format(window_size))

        for N in range(1, 64):
            snode = [ classNode(random.randrange(0, window_size)) for _ in range(N) ]
            successful_slots = 0
            slot_efficiency = 0

            for slot in range(TSLOTS):
                transmitted_nodes = []

                for i in range(N):
                    if not snode[i].ttl:
                        transmitted_nodes.append(i)
                        snode[i].ttl = random.randrange(0, window_size)
                    else:
                        snode[i].tick()

                if not transmitted_nodes:
                    pass

                if (len(transmitted_nodes) == 1):
                    successful_slots = successful_slots + 1

                if (len(transmitted_nodes) > 2):
                    for j in transmitted_nodes:
                        snode[j].ttl = random.randrange(0, window_size)

            slot_efficiency = (successful_slots/float(TSLOTS))

            print("N = {0:2d}: {1:f}".format(N, slot_efficiency))

            Nlist.append(N)
            selist.append(slot_efficiency)

        plt.plot(Nlist, selist)
        print ("")

    plt.xlabel("# of Nodes")
    plt.ylabel("Slot Efficiency")
    plt.legend(['W = 8', 'W = 16', 'W = 32', 'W = 64', 'W = 128'], loc='upper right')
    plt.axis([0, 64, 0, 0.5])
    plt.title('Slotted ALOHA Efficiency')
    plt.grid(linestyle='--')
    plt.show()

    return


if __name__ == "__main__":
    main()
